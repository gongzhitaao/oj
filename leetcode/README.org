#+TITLE: Leetcode Summary
#+OPTIONS: num:nil
#+STARTUP: content
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://gongzhitaao.org/orgcss/org.css" />

* Problems

  Some assumptions and notations
  - Space and time complexity *does not* include input and output.
  - =n= denotes the input length unless noted otherwise.
  - In case of graph, =E= denotes the number of edges, =V= number of
    vertices/nodes.

** 004 Median of Two Sorted Arrays                             :binarysearch:
   :PROPERTIES:
   :CUSTOM_ID: pro:leetcode-004
   :END:

   - Time \(O(\log(\min(m, n)))\)
   - Space \(O(1)\)

   A very genius algorithm is detailed in this post [[https://discuss.leetcode.com/topic/16797/very-concise-o-log-min-m-n-iterative-solution-with-detailed-explanation][Very concise
   O(log(min(M,N))) iterative solution with detailed explanation]].  We
   could generalize that algorithm to find the \(k\)th element of two
   sorted arrays in \(O(\log(\min(m,n,k)))\) time.

   Let's assume \(k\) is 0-based.

   - For one sorted array =A= of length \(n\), the \(k\)th element is
     =A[k]=, which divides the original array into two parts:
     =A[0..k-1]= and =A[k..n-1]=, i.e., there are exactly \(k\)
     element on the left of \(k\)th element no greater than =A[k]=.
   - For two sorted array =A= of length \(n\), =B= of length \(m\),
     and \(n \geq m\), if we could find positions =p=, =q= in =A= and
     =B= respectively such that
     1. =p= \(+\) =q= \(= k\)
     2. =A[p-1]= \(\leq\) =A[p]= and =A[p-1]= \(\leq\) =B[p]=
     3. =B[p-1]= \(\leq\) =B[p]= and =B[p-1]= \(\leq\) =A[p]=

     Then we say =z = min(A[p], B[p])= will be the \(k\)th element
     since there are \(k\) element no greater than =z=.  Note that
     this formulation applies to arrays with duplicates.

     Since =p= and =q= can be determined from each other, we could do
     a binary search in the shorter array =B=.  The =C++= code is
     available [[https://github.com/gongzhitaao/oj/blob/master/leetcode/004-median-of-two-sorted-arrays.cpp][gongzhitaao/oj]].

** 014 Longest Common Prefix                                          :adhoc:
   :PROPERTIES:
   :CUSTOM_ID: pro:leetcode-014
   :END:

   \(k\) is the length of longest common prefix.
   - Time \(O(nk)\)
   - Space \(O(1)\)

** 015 3Sum                                                           :adhoc:
   :PROPERTIES:
   :CUSTOM_ID: pro:leetcode-015
   :END:

   - Time \(O(n^2)\)
   - Space \(O(1)\)


   Sort the array first, then use two loops:
   - outer one =i= ranges =[0, n-3)=
   - inner one =j= starts from =i=, =k= starts from the end,
     - if sum is greater than expected, move =k= left,
     - if sum is less than expected, move =j= right,
     - otherwise move =j= right and =k= left
     - until they meet

** 035 Search Insert Position                                  :binarysearch:
   :PROPERTIES:
   :CUSTOM_ID: pro:leetcode-035
   :END:

   - Time \(O(\log n)\)
   - Space \(O(1)\)


   See the =C++= std implementation of =upper_bound= or =lower_bound=.

** 045 Jump Game II                                                   :adhoc:
   :PROPERTIES:
   :CUSTOM_ID: pro:leetcode-045
   :END:

   - Time \(O(n)\)
   - Space \(O(1)\)

** 057 Insert Interval                                                :adhoc:
   :PROPERTIES:
   :CUSTOM_ID: pro:leetcode-057
   :END:

   - Time \(O(n)\)
   - Space \(O(1)\)

** 078 Subsets                                                        :adhoc:
   :PROPERTIES:
   :CUSTOM_ID: pro:leetcode-078
   :END:

   - Time \(O(n^2)\)
   - Space \(O(1)\)

** 091 Decode Ways                                                    :adhoc:
   :PROPERTIES:
   :CUSTOM_ID: pro:leetcode-091
   :END:

   - Time \(O(n)\)
   - Space \(O(1)\)

** 113 Path Sum II                                                  :bfs:dfs:
   :PROPERTIES:
   :CUSTOM_ID: pro:leetcode-113
   :END:

   - Time \(O(E+V)\)
   - Space \(O(V)\)


   BFS is more space expansive up to a constant factor.

** 115 Distinct Sub-sequences                                            :dp:
   :PROPERTIES:
   :CUSTOM_ID: pro:leetcode-115
   :END:

   - Time \(O(mn)\) where m is length of =s=, n length of =t=.
   - Space \(O(mn)\)


   Naive divide-and-conquer search fails due to time limit.  This
   could be solved with DP.

   Suppose \(d[i][j]\) holds the number of solution for =t[0..i-1]=
   and =s[0..j-1]=, then =d[n][m]= is the final solution.

   State transition: \[d[i][j] = \begin{cases} d[i][j-1] +
   d[i-1][j-1], & \text{if}\ \text{T}[i-1] = \text{S}[j-1] \\ 1, &
   \text{otherwise} \end{cases}\]

** 116 Populating Next Right Pointers in Each Node                      :bfs:
   :PROPERTIES:
   :CUSTOM_ID: pro:leetcode-116
   :END:

   - Time \(O(E+V)\)
   - Space \(O(1)\)


   Two loops:
   - =i= iterates "row"
   - =j= iterates each level and connects each node's children.

** 117 Populating Next Right Pointers in Each Node II                   :bfs:
   :PROPERTIES:
   :CUSTOM_ID: pro:leetcode-117
   :END:

   - Time \(O(E+V)\)
   - Space \(O(1)\)


   Similar to [[#pro:leetcode-116][Leetcode 116]], but in addition, we need to keep track of
   each level's starting node.

** 142 Linked List Cycle II                                   :slowfastptr:
   :PROPERTIES:
   :CUSTOM_ID: pro:leetcode-142
   :END:

   - Time \(O(n)\)
   - Space \(O(1)\)


   Use slow and fast pointer.

** 199 Convert Sorted List to Binary Search Tree                    :bfs:dfs:
   :PROPERTIES:
   :CUSTOM_ID: pro:leetcode-199
   :END:

   - Time \(O(E+V)\)
   - Space \(O(V)\)


   Search the tree following BFS or DFS.
   - BFS, record the last element at every level.
   - DFS, right-to-left in-order traverse, record the element whenever
     level increases.

** 309 Best Time to Buy and Sell Stock with Cooldown                     :dp:
   :PROPERTIES:
   :CUSTOM_ID: pro:leetcode-309
   :END:

   - Time \(O(n^2)\)
   - Space \(O(n)\)

   Adpated from [[https://leetcode.com/discuss/72892/very-easy-to-understand-one-pass-solution-with-no-extra-space][@GWTW]] solution.  For day k, there are four states.

   1. Have stock, do nothing
   2. Have stock, sell the stock
   3. Have no stock, do nothing
   4. Have no stock, buy the stock


   Let =a[k]=, =b[k]=, =c[k]=, =d[k]= denote the maximum profit on
   day k ending in each of the four states respectively, =P[k]= the
   stock price on day k.  The final solution is =max(b[n], c[n])=.

   State transition:
   1. =a[k + 1] = max(a[k], d[k])=
   2. =b[k + 1] = max(a[k], d[k]) + P[k + 1] - P[k]=
   3. =c[k + 1] = max(b[k], c[k])=
   4. =d[k + 1] = max(c - P[k + 1])=


   Iterate from day 0 and initial values are all zeros.

** 367 Valid Perfect Square                                    :binarysearch:

   - Time \(O(\logn)\)
   - Space \(O(1)\)


   The input limits to 32-bit integer, therefore,
   - the running time is actually constant.
   - be careful about overflow.
