<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Leetcode Summary</title><meta name="generator" content="Org mode"><meta name="author" content="Zhitao Gong"><link rel="stylesheet" type="text/css" href="http://gongzhitaao.org/orgcss/org.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script></head><body><div id="content"><header><h1 class="title">Leetcode Summary</h1></header><nav id="table-of-contents"><h2>Table of Contents</h2><div id="text-table-of-contents"><ul><li><a href="#org8bb090b">Problems</a><ul><li><a href="#pro:leetcode-004">004 Median of Two Sorted Arrays&nbsp;&nbsp;&nbsp;<span class="tag"><span class="binarysearch">binarysearch</span></span></a></li><li><a href="#pro:leetcode-014">014 Longest Common Prefix&nbsp;&nbsp;&nbsp;<span class="tag"><span class="adhoc">adhoc</span></span></a></li><li><a href="#pro:leetcode-015">015 3Sum&nbsp;&nbsp;&nbsp;<span class="tag"><span class="3sum">3sum</span></span></a></li><li><a href="#pro:leetcode-035">035 Search Insert Position&nbsp;&nbsp;&nbsp;<span class="tag"><span class="binarysearch">binarysearch</span></span></a></li><li><a href="#pro:leetcode-039">039 Combination Sum&nbsp;&nbsp;&nbsp;<span class="tag"><span class="dfs">dfs</span></span></a></li><li><a href="#pro:leetcode-045">045 Jump Game II&nbsp;&nbsp;&nbsp;<span class="tag"><span class="adhoc">adhoc</span></span></a></li><li><a href="#pro:leetcode-057">057 Insert Interval&nbsp;&nbsp;&nbsp;<span class="tag"><span class="adhoc">adhoc</span></span></a></li><li><a href="#pro:leetcode-078">078 Subsets&nbsp;&nbsp;&nbsp;<span class="tag"><span class="adhoc">adhoc</span></span></a></li><li><a href="#pro:leetcode-091">091 Decode Ways&nbsp;&nbsp;&nbsp;<span class="tag"><span class="adhoc">adhoc</span></span></a></li><li><a href="#pro:leetcode-105">105 Construct Binary Tree from Preorder and Inorder Traversal&nbsp;&nbsp;&nbsp;<span class="tag"><span class="bst">bst</span></span></a></li><li><a href="#pro:leetcode-106">106 Construct Binary Tree from Inorder and Postorder Traversal&nbsp;&nbsp;&nbsp;<span class="tag"><span class="bst">bst</span></span></a></li><li><a href="#pro:leetcode-113">113 Path Sum II&nbsp;&nbsp;&nbsp;<span class="tag"><span class="bfs">bfs</span>&nbsp;<span class="dfs">dfs</span></span></a></li><li><a href="#pro:leetcode-115">115 Distinct Sub-sequences&nbsp;&nbsp;&nbsp;<span class="tag"><span class="dp">dp</span></span></a></li><li><a href="#pro:leetcode-116">116 Populating Next Right Pointers in Each Node&nbsp;&nbsp;&nbsp;<span class="tag"><span class="bfs">bfs</span></span></a></li><li><a href="#pro:leetcode-117">117 Populating Next Right Pointers in Each Node II&nbsp;&nbsp;&nbsp;<span class="tag"><span class="bfs">bfs</span></span></a></li><li><a href="#pro:leetcode-120">120 Triangle&nbsp;&nbsp;&nbsp;<span class="tag"><span class="dp">dp</span></span></a></li><li><a href="#pro:leetcode-142">142 Linked List Cycle II&nbsp;&nbsp;&nbsp;<span class="tag"><span class="slowfastptr">slowfastptr</span></span></a></li><li><a href="#pro:leetcode-163">163 Missing Ranges&nbsp;&nbsp;&nbsp;<span class="tag"><span class="adhoc">adhoc</span></span></a></li><li><a href="#org8981b37">166 Fraction to Recurring Decimal&nbsp;&nbsp;&nbsp;<span class="tag"><span class="adhoc">adhoc</span></span></a></li><li><a href="#pro:leetcode-199">199 Convert Sorted List to Binary Search Tree&nbsp;&nbsp;&nbsp;<span class="tag"><span class="bfs">bfs</span>&nbsp;<span class="dfs">dfs</span></span></a></li><li><a href="#pro:leetcode-200">200 Number of Islands&nbsp;&nbsp;&nbsp;<span class="tag"><span class="bfs">bfs</span>&nbsp;<span class="disjointset">disjointset</span></span></a></li><li><a href="#pro:leetcode-218">218 The Skyline Problem&nbsp;&nbsp;&nbsp;<span class="tag"><span class="divideconquer">divideconquer</span></span></a></li><li><a href="#pro:leetcode-259">259 3Sum Smaller&nbsp;&nbsp;&nbsp;<span class="tag"><span class="3sum">3sum</span></span></a></li><li><a href="#pro:leetcode-280">280 Wiggle Sort&nbsp;&nbsp;&nbsp;<span class="tag"><span class="sort">sort</span></span></a></li><li><a href="#pro:leetcode-286">286 Walls and Gates&nbsp;&nbsp;&nbsp;<span class="tag"><span class="bfs">bfs</span>&nbsp;<span class="dfs">dfs</span></span></a></li><li><a href="#pro:leetcode-288">288 Unique Word Abbreviation&nbsp;&nbsp;&nbsp;<span class="tag"><span class="adhoc">adhoc</span></span></a></li><li><a href="#pro:leetcode-305">305 Number of Islands II&nbsp;&nbsp;&nbsp;<span class="tag"><span class="disjointset">disjointset</span></span></a></li><li><a href="#pro:leetcode-308">308 Range Sum Query 2D - Mutable&nbsp;&nbsp;&nbsp;<span class="tag"><span class="bit">bit</span></span></a></li><li><a href="#pro:leetcode-309">309 Best Time to Buy and Sell Stock with Cooldown&nbsp;&nbsp;&nbsp;<span class="tag"><span class="dp">dp</span></span></a></li><li><a href="#pro:leetcode-312">312 Burst Balloons&nbsp;&nbsp;&nbsp;<span class="tag"><span class="dp">dp</span></span></a></li><li><a href="#pro:leetcode-315">315 Count of Smaller Numbers After Self&nbsp;&nbsp;&nbsp;<span class="tag"><span class="bit">bit</span>&nbsp;<span class="mergesort">mergesort</span></span></a></li><li><a href="#pro:leetcode-324">324 Wiggle Sort II&nbsp;&nbsp;&nbsp;<span class="tag"><span class="sort">sort</span></span></a></li><li><a href="#pro:leetcode-340">340 Longest Substring with At Most K Distinct Characters&nbsp;&nbsp;&nbsp;<span class="tag"><span class="dp">dp</span></span></a></li><li><a href="#pro:leetcode-367">367 Valid Perfect Square&nbsp;&nbsp;&nbsp;<span class="tag"><span class="binarysearch">binarysearch</span></span></a></li><li><a href="#pro:leetcode-368">368 Largest Divisible Subset&nbsp;&nbsp;&nbsp;<span class="tag"><span class="dp">dp</span></span></a></li><li><a href="#pro:leetcode-388">388 Longest Absolute File Path&nbsp;&nbsp;&nbsp;<span class="tag"><span class="dfs">dfs</span></span></a></li><li><a href="#pro:leetcode-394">394 Decode String&nbsp;&nbsp;&nbsp;<span class="tag"><span class="dfs">dfs</span></span></a></li><li><a href="#pro:leetcode-406">406 Queue Reconstruction by Height&nbsp;&nbsp;&nbsp;<span class="tag"><span class="dp">dp</span></span></a></li><li><a href="#pro:leetcode-421">421 Maximum XOR of Two Numbers in an Array&nbsp;&nbsp;&nbsp;<span class="tag"><span class="xor">xor</span></span></a></li></ul></li></ul></div></nav><div id="outline-container-org8bb090b" class="outline-2"><h2 id="org8bb090b">Problems</h2><div class="outline-text-2" id="text-org8bb090b"><p>Some assumptions and notations</p><ul class="org-ul"><li>Space and time complexity <b>does not</b> include input and output.</li><li><code>n</code> denotes the input length unless noted otherwise.</li><li>In case of graph, <code>E</code> denotes the number of edges, <code>V</code> number of vertices/nodes.</li></ul></div><div id="outline-container-org7eabd10" class="outline-3"><h3 id="pro:leetcode-004"><a id="org7eabd10" name="org7eabd10"></a>004 Median of Two Sorted Arrays&nbsp;&nbsp;&nbsp;<span class="tag"><span class="binarysearch">binarysearch</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-004"><ul class="org-ul"><li>Time \(O(\log(\min(m, n)))\)</li><li>Space \(O(1)\)</li></ul><p>A very genius algorithm is detailed in this post <a href="https://discuss.leetcode.com/topic/16797/very-concise-o-log-min-m-n-iterative-solution-with-detailed-explanation">Very concise O(log(min(M,N))) iterative solution with detailed explanation</a>. We could generalize that algorithm to find the \(k\)th element of two sorted arrays in \(O(\log(\min(m,n,k)))\) time.</p><p>Let's assume \(k\) is 0-based.</p><ul class="org-ul"><li>For one sorted array <code>A</code> of length \(n\), the \(k\)th element is <code>A[k]</code>, which divides the original array into two parts: <code>A[0..k-1]</code> and <code>A[k..n-1]</code>, i.e., there are exactly \(k\) element on the left of \(k\)th element no greater than <code>A[k]</code>.</li><li><p>For two sorted array <code>A</code> of length \(n\), <code>B</code> of length \(m\), and \(n \geq m\), if we could find positions <code>p</code>, <code>q</code> in <code>A</code> and <code>B</code> respectively such that</p><ol class="org-ol"><li><code>p</code> \(+\) <code>q</code> \(= k\)</li><li><code>A[p-1]</code> \(\leq\) <code>A[p]</code> and <code>A[p-1]</code> \(\leq\) <code>B[p]</code></li><li><code>B[p-1]</code> \(\leq\) <code>B[p]</code> and <code>B[p-1]</code> \(\leq\) <code>A[p]</code></li></ol><p>Then we say <code>z = min(A[p], B[p])</code> will be the \(k\)th element since there are \(k\) element no greater than <code>z</code>. Note that this formulation applies to arrays with duplicates.</p><p>Since <code>p</code> and <code>q</code> can be determined from each other, we could do a binary search in the shorter array <code>B</code>. The <code>C++</code> code is available <a href="https://github.com/gongzhitaao/oj/blob/master/leetcode/004-median-of-two-sorted-arrays.cpp">gongzhitaao/oj</a>.</p></li></ul></div></div><div id="outline-container-org8b0902a" class="outline-3"><h3 id="pro:leetcode-014"><a id="org8b0902a" name="org8b0902a"></a>014 Longest Common Prefix&nbsp;&nbsp;&nbsp;<span class="tag"><span class="adhoc">adhoc</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-014"><p>\(k\) is the length of longest common prefix.</p><ul class="org-ul"><li>Time \(O(nk)\)</li><li>Space \(O(1)\)</li></ul></div></div><div id="outline-container-org15d144d" class="outline-3"><h3 id="pro:leetcode-015"><a id="org15d144d" name="org15d144d"></a>015 3Sum&nbsp;&nbsp;&nbsp;<span class="tag"><span class="3sum">3sum</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-015"><ul class="org-ul"><li>Time \(O(n^2)\)</li><li>Space \(O(1)\)</li></ul><p>Sort the array first, then use two loops:</p><ul class="org-ul"><li>outer one <code>i</code> ranges <code>[0, n-3)</code></li><li>inner one <code>j</code> starts from <code>i</code>, <code>k</code> starts from the end,<ul class="org-ul"><li>if sum is greater than expected, move <code>k</code> left,</li><li>if sum is less than expected, move <code>j</code> right,</li><li>otherwise move <code>j</code> right and <code>k</code> left</li><li>until they meet</li></ul></li></ul></div></div><div id="outline-container-org11a2718" class="outline-3"><h3 id="pro:leetcode-035"><a id="org11a2718" name="org11a2718"></a>035 Search Insert Position&nbsp;&nbsp;&nbsp;<span class="tag"><span class="binarysearch">binarysearch</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-035"><ul class="org-ul"><li>Time \(O(\log n)\)</li><li>Space \(O(1)\)</li></ul><p>See the <code>C++</code> std implementation of <code>upper_bound</code> or <code>lower_bound</code>.</p></div></div><div id="outline-container-org4df4fa7" class="outline-3"><h3 id="pro:leetcode-039"><a id="org4df4fa7" name="org4df4fa7"></a>039 Combination Sum&nbsp;&nbsp;&nbsp;<span class="tag"><span class="dfs">dfs</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-039"><ul class="org-ul"><li>Time Uncertain</li><li>Space Uncertain</li></ul><p>Not sure about the complexity of the problem. It is rather intricate to determine in general. The idea is simple, i.e., brutal force with DFS, trying every possible combination. Note that the problem states that the provides candidates is a <i>set</i>, so you do not have to worry about <i>duplicates</i>.</p></div></div><div id="outline-container-org6d0136b" class="outline-3"><h3 id="pro:leetcode-045"><a id="org6d0136b" name="org6d0136b"></a>045 Jump Game II&nbsp;&nbsp;&nbsp;<span class="tag"><span class="adhoc">adhoc</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-045"><ul class="org-ul"><li>Time \(O(n)\)</li><li>Space \(O(1)\)</li></ul></div></div><div id="outline-container-org3183ae2" class="outline-3"><h3 id="pro:leetcode-057"><a id="org3183ae2" name="org3183ae2"></a>057 Insert Interval&nbsp;&nbsp;&nbsp;<span class="tag"><span class="adhoc">adhoc</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-057"><ul class="org-ul"><li>Time \(O(n)\)</li><li>Space \(O(1)\)</li></ul></div></div><div id="outline-container-orgebc363d" class="outline-3"><h3 id="pro:leetcode-078"><a id="orgebc363d" name="orgebc363d"></a>078 Subsets&nbsp;&nbsp;&nbsp;<span class="tag"><span class="adhoc">adhoc</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-078"><ul class="org-ul"><li>Time \(O(n^2)\)</li><li>Space \(O(1)\)</li></ul></div></div><div id="outline-container-org1b1fa60" class="outline-3"><h3 id="pro:leetcode-091"><a id="org1b1fa60" name="org1b1fa60"></a>091 Decode Ways&nbsp;&nbsp;&nbsp;<span class="tag"><span class="adhoc">adhoc</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-091"><ul class="org-ul"><li>Time \(O(n)\)</li><li>Space \(O(1)\)</li></ul></div></div><div id="outline-container-org93e1ef4" class="outline-3"><h3 id="pro:leetcode-105"><a id="org93e1ef4" name="org93e1ef4"></a>105 Construct Binary Tree from Preorder and Inorder Traversal&nbsp;&nbsp;&nbsp;<span class="tag"><span class="bst">bst</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-105"><p>Same as <a href="#pro:leetcode-106">Leetcode 106</a>.</p></div></div><div id="outline-container-org38d03ca" class="outline-3"><h3 id="pro:leetcode-106"><a id="org38d03ca" name="org38d03ca"></a>106 Construct Binary Tree from Inorder and Postorder Traversal&nbsp;&nbsp;&nbsp;<span class="tag"><span class="bst">bst</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-106"><p>Time \(O(n^2)\) space \(O(1)\) or Time \(O(n)\) space \(O(n)\)</p><ul class="org-ul"><li>The last one in post-order traverse is the parent.</li><li>Find the position of the parent in the in-order traverse.</li><li>Recursively construct the left and right children.</li></ul><p>If we store in a hash map all the values' position in the in-order traverse, it runs in \(O(n)\) at the expense of \(O(n)\) space, otherwise it runs in \(O(n^2)\).</p></div></div><div id="outline-container-org4ed9a1b" class="outline-3"><h3 id="pro:leetcode-113"><a id="org4ed9a1b" name="org4ed9a1b"></a>113 Path Sum II&nbsp;&nbsp;&nbsp;<span class="tag"><span class="bfs">bfs</span>&nbsp;<span class="dfs">dfs</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-113"><ul class="org-ul"><li>Time \(O(E+V)\)</li><li>Space \(O(V)\)</li></ul><p>BFS is more space expansive up to a constant factor.</p></div></div><div id="outline-container-orge9808ae" class="outline-3"><h3 id="pro:leetcode-115"><a id="orge9808ae" name="orge9808ae"></a>115 Distinct Sub-sequences&nbsp;&nbsp;&nbsp;<span class="tag"><span class="dp">dp</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-115"><ul class="org-ul"><li>Time \(O(mn)\) where m is length of <code>s</code>, n length of <code>t</code>.</li><li>Space \(O(mn)\)</li></ul><p>Naive divide-and-conquer search fails due to time limit. This could be solved with DP.</p><p>Suppose \(d[i][j]\) holds the number of solution for <code>t[0..i-1]</code> and <code>s[0..j-1]</code>, then <code>d[n][m]</code> is the final solution.</p><p>State transition: \[d[i][j] = \begin{cases} d[i][j-1] + d[i-1][j-1], &amp; \text{if}\ \text{T}[i-1] = \text{S}[j-1] \\ 1, &amp; \text{otherwise} \end{cases}\]</p></div></div><div id="outline-container-orgc10b853" class="outline-3"><h3 id="pro:leetcode-116"><a id="orgc10b853" name="orgc10b853"></a>116 Populating Next Right Pointers in Each Node&nbsp;&nbsp;&nbsp;<span class="tag"><span class="bfs">bfs</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-116"><ul class="org-ul"><li>Time \(O(E+V)\)</li><li>Space \(O(1)\)</li></ul><p>Two loops:</p><ul class="org-ul"><li><code>i</code> iterates "row"</li><li><code>j</code> iterates each level and connects each node's children.</li></ul></div></div><div id="outline-container-org2148a41" class="outline-3"><h3 id="pro:leetcode-117"><a id="org2148a41" name="org2148a41"></a>117 Populating Next Right Pointers in Each Node II&nbsp;&nbsp;&nbsp;<span class="tag"><span class="bfs">bfs</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-117"><ul class="org-ul"><li>Time \(O(E+V)\)</li><li>Space \(O(1)\)</li></ul><p>Similar to <a href="#pro:leetcode-116">Leetcode 116</a>, but in addition, we need to keep track of each level's starting node.</p></div></div><div id="outline-container-orgcb03de0" class="outline-3"><h3 id="pro:leetcode-120"><a id="orgcb03de0" name="orgcb03de0"></a>120 Triangle&nbsp;&nbsp;&nbsp;<span class="tag"><span class="dp">dp</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-120"><ul class="org-ul"><li>Time \(O(n^2)\)</li><li>Space \(O(n)\)</li></ul><p>Dynamic programming. The <code>sum</code> holds current sum, then the state transition for <code>sum[i]</code> is <code>sum[i] = min(sum[i-1], sum[i]) + triangle[i]</code>. Be careful to</p><ol class="org-ol"><li>backup <code>sum[i-1]</code>.</li><li>initialize <code>sum</code> to be all maximum integer value except for the first one, which is initialized to 0.</li></ol></div></div><div id="outline-container-org8c23c4d" class="outline-3"><h3 id="pro:leetcode-142"><a id="org8c23c4d" name="org8c23c4d"></a>142 Linked List Cycle II&nbsp;&nbsp;&nbsp;<span class="tag"><span class="slowfastptr">slowfastptr</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-142"><ul class="org-ul"><li>Time \(O(n)\)</li><li>Space \(O(1)\)</li></ul><p>Use slow and fast pointer.</p></div></div><div id="outline-container-org1e8dcbf" class="outline-3"><h3 id="pro:leetcode-163"><a id="org1e8dcbf" name="org1e8dcbf"></a>163 Missing Ranges&nbsp;&nbsp;&nbsp;<span class="tag"><span class="adhoc">adhoc</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-163"><ul class="org-ul"><li>Time \(O(n)\)</li><li>Space \(O(1)\)</li></ul><p>Just iterate through the array. Watch out for edge cases, like empty array, boundary values.</p></div></div><div id="outline-container-org8981b37" class="outline-3"><h3 id="org8981b37">166 Fraction to Recurring Decimal&nbsp;&nbsp;&nbsp;<span class="tag"><span class="adhoc">adhoc</span></span></h3><div class="outline-text-3" id="text-org8981b37"><ul class="org-ul"><li>Time uncertain</li><li>Space uncertain</li></ul><p>Just perform <a href="https://en.wikipedia.org/wiki/Long_division">long division</a>. As for repeating fraction detection, if we come across the same remainder, then we have a repeating fraction from where remainder occurs first.</p><p>Edge cases: negative case, no negative sign when numerator is 0, no decimal point when no fraction part.</p></div></div><div id="outline-container-org3a9ff60" class="outline-3"><h3 id="pro:leetcode-199"><a id="org3a9ff60" name="org3a9ff60"></a>199 Convert Sorted List to Binary Search Tree&nbsp;&nbsp;&nbsp;<span class="tag"><span class="bfs">bfs</span>&nbsp;<span class="dfs">dfs</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-199"><ul class="org-ul"><li>Time \(O(E+V)\)</li><li>Space \(O(V)\)</li></ul><p>Search the tree following BFS or DFS.</p><ul class="org-ul"><li>BFS, record the last element at every level.</li><li>DFS, right-to-left in-order traverse, record the element whenever level increases.</li></ul></div></div><div id="outline-container-org505dc27" class="outline-3"><h3 id="pro:leetcode-200"><a id="org505dc27" name="org505dc27"></a>200 Number of Islands&nbsp;&nbsp;&nbsp;<span class="tag"><span class="bfs">bfs</span>&nbsp;<span class="disjointset">disjointset</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-200"><ul class="org-ul"><li>Time \(O(mn)\)</li><li>Space \(O(mn)\)</li></ul><p>Similar to <a href="#pro:leetcode-305">Leetcode 305</a>, we can use disjoint-set. Or we could do a BFS on each land position.</p></div></div><div id="outline-container-org300c8df" class="outline-3"><h3 id="pro:leetcode-218"><a id="org300c8df" name="org300c8df"></a>218 The Skyline Problem&nbsp;&nbsp;&nbsp;<span class="tag"><span class="divideconquer">divideconquer</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-218"><ul class="org-ul"><li>Time \(O(n\log n)\)</li><li>Space \(O(n)\)</li></ul><p>Naive solution is to create skyline for each building and merge them one by one, which runs in \(O(n^2)\) when all buildings are disjoint.</p><p>Improved version is to use merge-sort idea, split the problem into two half problem and merge the solutions. How to merge sub-skylines? Similar to merge-sort, start from the first elements of two skylines, compare the X coordinates, pick the smaller one, height is maximum of current heights from both skylines. If the new height is the same as old one, do not insert it as it will result in a consecutive horizontal lines of equal height.</p></div></div><div id="outline-container-orgf09574e" class="outline-3"><h3 id="pro:leetcode-259"><a id="orgf09574e" name="orgf09574e"></a>259 3Sum Smaller&nbsp;&nbsp;&nbsp;<span class="tag"><span class="3sum">3sum</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-259"><ul class="org-ul"><li>Time \(O(n^2)\)</li><li>Space \(O(1)\)</li></ul><p>Similar to <a href="#pro:leetcode-015">Leetcode 015</a>, we keep two pointer <code>lo</code> and <code>hi</code> in the inner loop. The critical observation is if <code>nums[i] + nums[lo] + nums[hi] &lt; target</code>, then any <code>hi</code> in the range <code>(lo, hi]</code> satisfies the condition.</p></div></div><div id="outline-container-orgf24e4aa" class="outline-3"><h3 id="pro:leetcode-280"><a id="orgf24e4aa" name="orgf24e4aa"></a>280 Wiggle Sort&nbsp;&nbsp;&nbsp;<span class="tag"><span class="sort">sort</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-280"><ul class="org-ul"><li>Time \(O(n)\)</li><li>Space \(O(1)\)</li></ul><p>Let's suppose we are at position <code>k</code>, array <code>A[0..k]</code> are wiggle-sorted already.</p><dl class="org-dl"><dt>Case 1 <code>k</code> is odd</dt><dd>If <code>A[k+1] &lt;= A[K]</code>, no change needed. If <code>A[k+1] &gt; A[k]</code>, <i>after</i> swapping <code>A[k+1]</code> with <code>A[k]</code>, we have <code>A[k-1] &lt;= A[k] &gt; A[k+1]</code>. So <code>A[0..k+1]</code> is wiggle-sorted.</dd><dt>Case 2 <code>k</code> is even</dt><dd>Argument similar to the above.</dd></dl><p>So just sweep through the array, swap any two element that does not satisfy the wiggle condition.</p></div></div><div id="outline-container-org8fdc6f5" class="outline-3"><h3 id="pro:leetcode-286"><a id="org8fdc6f5" name="org8fdc6f5"></a>286 Walls and Gates&nbsp;&nbsp;&nbsp;<span class="tag"><span class="bfs">bfs</span>&nbsp;<span class="dfs">dfs</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-286"><ul class="org-ul"><li>Time \(O(mn)\)</li><li>Space \(O(mn)\)</li></ul><p>Start from each gate, do a BFS or DFS to update the distance for each room.</p></div></div><div id="outline-container-org5822ca5" class="outline-3"><h3 id="pro:leetcode-288"><a id="org5822ca5" name="org5822ca5"></a>288 Unique Word Abbreviation&nbsp;&nbsp;&nbsp;<span class="tag"><span class="adhoc">adhoc</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-288"><ul class="org-ul"><li>Time initialization \(O(n)\), query \(O(1)\)</li><li>Space \(O(n)\)</li></ul><p>The question is straightforward, however, beware of the definition of "being unique", i.e., either the word itself does not exist in the dictionary or its key does not exist if it is in the dictionary.</p></div></div><div id="outline-container-orgff6f814" class="outline-3"><h3 id="pro:leetcode-305"><a id="orgff6f814" name="orgff6f814"></a>305 Number of Islands II&nbsp;&nbsp;&nbsp;<span class="tag"><span class="disjointset">disjointset</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-305"><ul class="org-ul"><li>Time \(O(k\log mn)\) actually this is the query time, not including the initialization time, which is \(O(mn)\).</li><li>Space \(O(mn)\)</li></ul><p>Simple application of disjoint-set. For each new land, first we make itself a set, then union with its neighbors, if any.</p><p>The initial count is 0, for each new land, first we make a set of its own, increment the count. Then whenever we successfully union it with one of its neighbors, decrement the count.</p></div></div><div id="outline-container-orgec4b308" class="outline-3"><h3 id="pro:leetcode-308"><a id="orgec4b308" name="orgec4b308"></a>308 Range Sum Query 2D - Mutable&nbsp;&nbsp;&nbsp;<span class="tag"><span class="bit">bit</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-308"><ul class="org-ul"><li>Time \(O(\log n)\) for update and sum</li><li>Space \(O(n^2)\)</li></ul><p>2D binary index tree (Fenwick tree).</p></div></div><div id="outline-container-orgd463a85" class="outline-3"><h3 id="pro:leetcode-309"><a id="orgd463a85" name="orgd463a85"></a>309 Best Time to Buy and Sell Stock with Cooldown&nbsp;&nbsp;&nbsp;<span class="tag"><span class="dp">dp</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-309"><ul class="org-ul"><li>Time \(O(n^2)\)</li><li>Space \(O(n)\)</li></ul><p>Adpated from <a href="https://leetcode.com/discuss/72892/very-easy-to-understand-one-pass-solution-with-no-extra-space">@GWTW</a> solution. For day k, there are four states.</p><ol class="org-ol"><li>Have stock, do nothing</li><li>Have stock, sell the stock</li><li>Have no stock, do nothing</li><li>Have no stock, buy the stock</li></ol><p>Let <code>a[k]</code>, <code>b[k]</code>, <code>c[k]</code>, <code>d[k]</code> denote the maximum profit on day k ending in each of the four states respectively, <code>P[k]</code> the stock price on day k. The final solution is <code>max(b[n], c[n])</code>.</p><p>State transition:</p><ol class="org-ol"><li><code>a[k + 1] = max(a[k], d[k])</code></li><li><code>b[k + 1] = max(a[k], d[k]) + P[k + 1] - P[k]</code></li><li><code>c[k + 1] = max(b[k], c[k])</code></li><li><code>d[k + 1] = max(c - P[k + 1])</code></li></ol><p>Iterate from day 0 and initial values are all zeros.</p></div></div><div id="outline-container-org0a1c570" class="outline-3"><h3 id="pro:leetcode-312"><a id="org0a1c570" name="org0a1c570"></a>312 Burst Balloons&nbsp;&nbsp;&nbsp;<span class="tag"><span class="dp">dp</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-312"><ul class="org-ul"><li>Time \(O(n^3)\)</li><li>Space \(O(n^2)\)</li></ul><p>If we divide the problem by <i>first explosion</i> position, the subproblems are <b>not</b> independent. However if we divide the problem by <i>last explosion</i> position, then the subproblems are independent. Let <code>v[i][j]</code> denote the max coin required in range <code>(i,j)</code> where <code>i</code> and <code>j</code> are off-bound. The state transition function is</p><p>\[v[i][j] = \max_k(v[i][j], v[i][k]+v[k][j]+nums[i]\times nums[k]\times nums[j])\]</p><p>where, \(i &lt; k &lt; j\).</p><p>Similar to Floyd-Warshall algorithms we need three nested loops to update the value matrix <code>v</code> and <code>v[0][n+1]</code> is the final result.</p><p>And as a side note, based on the state transition function, we could see that <code>v[i][j]</code> depends on values <i>below</i> and <i>left</i>.</p></div></div><div id="outline-container-org53e05eb" class="outline-3"><h3 id="pro:leetcode-315"><a id="org53e05eb" name="org53e05eb"></a>315 Count of Smaller Numbers After Self&nbsp;&nbsp;&nbsp;<span class="tag"><span class="bit">bit</span>&nbsp;<span class="mergesort">mergesort</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-315"><p>Let's forget about the binary index tree for now. The basic idea is simple.</p><ol class="org-ol"><li>We maintain a counter array <code>count[]</code> which stores the count of each element.</li><li>Sort a copy of the original array to Get each element's position after being sorted, stored in a hash map <code>h[]</code>.</li><li>Then traverse the original list in reverse order.<ol class="org-ol"><li>For each element <code>e</code>, we increment by 1 its counter <code>count[h[e]]</code>.</li><li>Sum all the numbers in the range <code>count[0...h[e]-1]</code> gives the number of smaller elements after <code>e</code>.</li></ol></li></ol><p>Now this is a classic binary indexed tree problem, update and query. In the actual implementation, we may not need the counter array at all. We only need the binary indexed array.</p></div></div><div id="outline-container-org3cff237" class="outline-3"><h3 id="pro:leetcode-324"><a id="org3cff237" name="org3cff237"></a>324 Wiggle Sort II&nbsp;&nbsp;&nbsp;<span class="tag"><span class="sort">sort</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-324"><p>This is problem looks similar to <a href="#pro:leetcode-280">Leetcode 280</a>. However the algorithm is drastically different.</p><ul class="org-ul"><li><a href="#pro:leetcode-280">Leetcode 280</a>, <code>nums[0] &lt;= nums[1] &gt;= nums[2] &lt;= nums[3]....</code></li><li>Leetcode 324, <code>nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]...</code></li></ul><p>In other words, for <a href="#pro:leetcode-280">Leetcode 280</a>, there are always solutions, while it's not true for this problem. For example, <code>[2,2,2,4,3]</code> and <code>[2,3,2,4,3]</code>. Both satisfy the wiggle sort condition, but only the latter satisfy the wiggle sort II condition.</p><p>Assume the problem is always solvable, we need to find the median of the array, and whatever smaller than the median goes to even positions and the rest goes to odd positions.</p></div></div><div id="outline-container-org171b91a" class="outline-3"><h3 id="pro:leetcode-340"><a id="org171b91a" name="org171b91a"></a>340 Longest Substring with At Most K Distinct Characters&nbsp;&nbsp;&nbsp;<span class="tag"><span class="dp">dp</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-340"><ul class="org-ul"><li>Time uncertain, it seems between \(O(n)\) and \(O(n^2)\).</li><li>Space \(O(n)\)</li></ul><p>Iterate through the array <code>A</code> with two pointers, <code>i</code> and <code>j</code>. And <code>hashmap[j]</code> contains the count of each character that appears in the longest substring ending at <code>j</code>.</p><ol class="org-ol"><li>If <code>A[j+1]</code> is in the hash map, increment the corresponding count.</li><li>If <code>A[j+1]</code> is not in the hash map, insert it into the hash map with count 1, and if the total size of the hash map is larger than <code>k</code>, then increment <code>i</code> until the size of hash map is no larger than <code>k</code>.</li></ol></div></div><div id="outline-container-orgdc5407a" class="outline-3"><h3 id="pro:leetcode-367"><a id="orgdc5407a" name="orgdc5407a"></a>367 Valid Perfect Square&nbsp;&nbsp;&nbsp;<span class="tag"><span class="binarysearch">binarysearch</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-367"><ul class="org-ul"><li>Time \(O(\log n)\)</li><li>Space \(O(1)\)</li></ul><p>The input limits to 32-bit integer, therefore,</p><ul class="org-ul"><li>the running time is actually constant.</li><li>be careful about overflow.</li></ul></div></div><div id="outline-container-org110fa55" class="outline-3"><h3 id="pro:leetcode-368"><a id="org110fa55" name="org110fa55"></a>368 Largest Divisible Subset&nbsp;&nbsp;&nbsp;<span class="tag"><span class="dp">dp</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-368"><p>First <i>sort</i> the array in ascending order. Let <code>v[i]</code> denote the largest divisible subset ending with <code>nums[i]</code>, the state transition function is</p><p>\[v[i] = \max_{v[i].length} \left\{v[i]\bigcup v[j] \,\middle|\, \forall\, nums[i] \equiv 0 \bmod{nums[j]}\right\}\]</p></div></div><div id="outline-container-orge1e6255" class="outline-3"><h3 id="pro:leetcode-388"><a id="orge1e6255" name="orge1e6255"></a>388 Longest Absolute File Path&nbsp;&nbsp;&nbsp;<span class="tag"><span class="dfs">dfs</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-388"><ul class="org-ul"><li>Time \(O(n)\)</li><li>Space \(O(n)\)</li></ul><p>The string is actually the output of DFS traversal of the directory tree. The <code>\n</code> delimits the end of an item (directory/file) name, while <code>\t</code> gives the current level of the item. Just simulate the DFS traversal, store the current path length (not counting the directory delimiter <code>/</code>) at each node. When ever we reach a file, i.e., a leaf node, update the current max length.</p></div></div><div id="outline-container-org14177d0" class="outline-3"><h3 id="pro:leetcode-394"><a id="org14177d0" name="org14177d0"></a>394 Decode String&nbsp;&nbsp;&nbsp;<span class="tag"><span class="dfs">dfs</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-394"><p>Time and space are uncertain.</p><p>Expand the string in a DFS fashion, i.e., expand the inner most repeater first.</p></div></div><div id="outline-container-orga217c4b" class="outline-3"><h3 id="pro:leetcode-406"><a id="orga217c4b" name="orga217c4b"></a>406 Queue Reconstruction by Height&nbsp;&nbsp;&nbsp;<span class="tag"><span class="dp">dp</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-406"><ul class="org-ul"><li>Time \(O(n^2)\)</li><li>Space \(O(n)\)</li></ul><p>Wherever we insert a shorter person has no influence on taller people. Therefor, sort the people by height in <i>non-ascending order</i>, breaking ties by k-value in <i>ascending order</i>. And we will have a independent subproblem. Suppose we have already have the first <code>k</code> persons in a proper order, for the <code>k+1</code> person with <code>n</code> people in front of him, just insert it in position <code>n</code>.</p></div></div><div id="outline-container-org6a28ad3" class="outline-3"><h3 id="pro:leetcode-421"><a id="org6a28ad3" name="org6a28ad3"></a>421 Maximum XOR of Two Numbers in an Array&nbsp;&nbsp;&nbsp;<span class="tag"><span class="xor">xor</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-421"><ul class="org-ul"><li>Time \(O(31n) = O(n)\)</li><li>Space \(O(n)\)</li></ul><p>The XOR has a property: if \(c = a\oplus b\), then \(b = c\oplus a\). This is widely used in swapping two numbers, i.e., \(x = x \oplus y, y = x \oplus y, x = x \oplus y\).</p><p>We construct the solution, \(s\), from most significant bit to the least, bit by bit. Let \(a_k = a \gg (31 - k)\) denote the \(k\) (0-based) most significant bits for the number \(a\). Suppose we have already determined \(s_k\), now we want to determine the \(s_{k+1}\).</p><ul class="org-ul"><li>First \(s_{k+1} = s_{k} \ll 1\), i.e., appending 0 to the solution, and change it to 1 if we can using the following steps.</li><li>For each element \(a\) in the <i>array</i>, store \(a_{k+1}\) in a hash table.</li><li>For each element \(a\) in the <i>hash table</i>, if \(s_{k+1}\oplus 1\oplus a\) is also in the hash table, then we could set the current bit to 1, i.e., \(s_{k+1} = s_{k+1}\oplus 1\).</li></ul></div></div></div></div><div id="postamble" class="status"><a class="author" href="http://gongzhitaao.org">Zhitao Gong</a> / <span class="date">2016-11-17 Thu 13:58</span><span class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.5.1 (<a href="http://orgmode.org">Org</a> mode 9.0)</span></div></body></html>