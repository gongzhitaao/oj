<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Leetcode Summary</title><meta name="generator" content="Org-mode"><meta name="author" content="Zhitao Gong"><link rel="stylesheet" type="text/css" href="http://gongzhitaao.org/orgcss/org.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script></head><body><div id="content"><header><h1 class="title">Leetcode Summary</h1></header><nav id="table-of-contents"><h2>Table of Contents</h2><div id="text-table-of-contents"><ul><li><a href="#orgheadline1">Problems</a><ul><li><a href="#pro:leetcode-004">004 Median of Two Sorted Arrays&nbsp;&nbsp;&nbsp;<span class="tag"><span class="binarysearch">binarysearch</span></span></a></li><li><a href="#pro:leetcode-014">014 Longest Common Prefix&nbsp;&nbsp;&nbsp;<span class="tag"><span class="adhoc">adhoc</span></span></a></li><li><a href="#pro:leetcode-015">015 3Sum&nbsp;&nbsp;&nbsp;<span class="tag"><span class="adhoc">adhoc</span></span></a></li><li><a href="#pro:leetcode-035">035 Search Insert Position&nbsp;&nbsp;&nbsp;<span class="tag"><span class="binarysearch">binarysearch</span></span></a></li><li><a href="#pro:leetcode-045">045 Jump Game II&nbsp;&nbsp;&nbsp;<span class="tag"><span class="adhoc">adhoc</span></span></a></li><li><a href="#pro:leetcode-057">057 Insert Interval&nbsp;&nbsp;&nbsp;<span class="tag"><span class="adhoc">adhoc</span></span></a></li><li><a href="#pro:leetcode-078">078 Subsets&nbsp;&nbsp;&nbsp;<span class="tag"><span class="adhoc">adhoc</span></span></a></li><li><a href="#pro:leetcode-091">091 Decode Ways&nbsp;&nbsp;&nbsp;<span class="tag"><span class="adhoc">adhoc</span></span></a></li><li><a href="#pro:leetcode-105">105 Construct Binary Tree from Preorder and Inorder Traversal&nbsp;&nbsp;&nbsp;<span class="tag"><span class="bst">bst</span></span></a></li><li><a href="#pro:leetcode-106">106 Construct Binary Tree from Inorder and Postorder Traversal&nbsp;&nbsp;&nbsp;<span class="tag"><span class="bst">bst</span></span></a></li><li><a href="#pro:leetcode-113">113 Path Sum II&nbsp;&nbsp;&nbsp;<span class="tag"><span class="bfs">bfs</span>&nbsp;<span class="dfs">dfs</span></span></a></li><li><a href="#pro:leetcode-115">115 Distinct Sub-sequences&nbsp;&nbsp;&nbsp;<span class="tag"><span class="dp">dp</span></span></a></li><li><a href="#pro:leetcode-116">116 Populating Next Right Pointers in Each Node&nbsp;&nbsp;&nbsp;<span class="tag"><span class="bfs">bfs</span></span></a></li><li><a href="#pro:leetcode-117">117 Populating Next Right Pointers in Each Node II&nbsp;&nbsp;&nbsp;<span class="tag"><span class="bfs">bfs</span></span></a></li><li><a href="#pro:leetcode-142">142 Linked List Cycle II&nbsp;&nbsp;&nbsp;<span class="tag"><span class="slowfastptr">slowfastptr</span></span></a></li><li><a href="#orgheadline17">166 Fraction to Recurring Decimal&nbsp;&nbsp;&nbsp;<span class="tag"><span class="adhoc">adhoc</span></span></a></li><li><a href="#pro:leetcode-199">199 Convert Sorted List to Binary Search Tree&nbsp;&nbsp;&nbsp;<span class="tag"><span class="bfs">bfs</span>&nbsp;<span class="dfs">dfs</span></span></a></li><li><a href="#pro:leetcode-309">309 Best Time to Buy and Sell Stock with Cooldown&nbsp;&nbsp;&nbsp;<span class="tag"><span class="dp">dp</span></span></a></li><li><a href="#pro:leetcode-367">367 Valid Perfect Square&nbsp;&nbsp;&nbsp;<span class="tag"><span class="binarysearch">binarysearch</span></span></a></li></ul></li></ul></div></nav><div id="outline-container-orgheadline1" class="outline-2"><h2 id="orgheadline1">Problems</h2><div class="outline-text-2" id="text-orgheadline1"><p>Some assumptions and notations</p><ul class="org-ul"><li>Space and time complexity <b>does not</b> include input and output.</li><li><code>n</code> denotes the input length unless noted otherwise.</li><li>In case of graph, <code>E</code> denotes the number of edges, <code>V</code> number of vertices/nodes.</li></ul></div><div id="outline-container-orgheadline2" class="outline-3"><h3 id="pro:leetcode-004"><a id="orgheadline2"></a>004 Median of Two Sorted Arrays&nbsp;&nbsp;&nbsp;<span class="tag"><span class="binarysearch">binarysearch</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-004"><ul class="org-ul"><li>Time \(O(\log(\min(m, n)))\)</li><li>Space \(O(1)\)</li></ul><p>A very genius algorithm is detailed in this post <a href="https://discuss.leetcode.com/topic/16797/very-concise-o-log-min-m-n-iterative-solution-with-detailed-explanation">Very concise O(log(min(M,N))) iterative solution with detailed explanation</a>. We could generalize that algorithm to find the \(k\)th element of two sorted arrays in \(O(\log(\min(m,n,k)))\) time.</p><p>Let's assume \(k\) is 0-based.</p><ul class="org-ul"><li>For one sorted array <code>A</code> of length \(n\), the \(k\)th element is <code>A[k]</code>, which divides the original array into two parts: <code>A[0..k-1]</code> and <code>A[k..n-1]</code>, i.e., there are exactly \(k\) element on the left of \(k\)th element no greater than <code>A[k]</code>.</li><li><p>For two sorted array <code>A</code> of length \(n\), <code>B</code> of length \(m\), and \(n \geq m\), if we could find positions <code>p</code>, <code>q</code> in <code>A</code> and <code>B</code> respectively such that</p><ol class="org-ol"><li><code>p</code> \(+\) <code>q</code> \(= k\)</li><li><code>A[p-1]</code> \(\leq\) <code>A[p]</code> and <code>A[p-1]</code> \(\leq\) <code>B[p]</code></li><li><code>B[p-1]</code> \(\leq\) <code>B[p]</code> and <code>B[p-1]</code> \(\leq\) <code>A[p]</code></li></ol><p>Then we say <code>z = min(A[p], B[p])</code> will be the \(k\)th element since there are \(k\) element no greater than <code>z</code>. Note that this formulation applies to arrays with duplicates.</p><p>Since <code>p</code> and <code>q</code> can be determined from each other, we could do a binary search in the shorter array <code>B</code>. The <code>C++</code> code is available <a href="https://github.com/gongzhitaao/oj/blob/master/leetcode/004-median-of-two-sorted-arrays.cpp">gongzhitaao/oj</a>.</p></li></ul></div></div><div id="outline-container-orgheadline3" class="outline-3"><h3 id="pro:leetcode-014"><a id="orgheadline3"></a>014 Longest Common Prefix&nbsp;&nbsp;&nbsp;<span class="tag"><span class="adhoc">adhoc</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-014"><p>\(k\) is the length of longest common prefix.</p><ul class="org-ul"><li>Time \(O(nk)\)</li><li>Space \(O(1)\)</li></ul></div></div><div id="outline-container-orgheadline4" class="outline-3"><h3 id="pro:leetcode-015"><a id="orgheadline4"></a>015 3Sum&nbsp;&nbsp;&nbsp;<span class="tag"><span class="adhoc">adhoc</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-015"><ul class="org-ul"><li>Time \(O(n^2)\)</li><li>Space \(O(1)\)</li></ul><p>Sort the array first, then use two loops:</p><ul class="org-ul"><li>outer one <code>i</code> ranges <code>[0, n-3)</code></li><li>inner one <code>j</code> starts from <code>i</code>, <code>k</code> starts from the end,<ul class="org-ul"><li>if sum is greater than expected, move <code>k</code> left,</li><li>if sum is less than expected, move <code>j</code> right,</li><li>otherwise move <code>j</code> right and <code>k</code> left</li><li>until they meet</li></ul></li></ul></div></div><div id="outline-container-orgheadline5" class="outline-3"><h3 id="pro:leetcode-035"><a id="orgheadline5"></a>035 Search Insert Position&nbsp;&nbsp;&nbsp;<span class="tag"><span class="binarysearch">binarysearch</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-035"><ul class="org-ul"><li>Time \(O(\log n)\)</li><li>Space \(O(1)\)</li></ul><p>See the <code>C++</code> std implementation of <code>upper_bound</code> or <code>lower_bound</code>.</p></div></div><div id="outline-container-orgheadline6" class="outline-3"><h3 id="pro:leetcode-045"><a id="orgheadline6"></a>045 Jump Game II&nbsp;&nbsp;&nbsp;<span class="tag"><span class="adhoc">adhoc</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-045"><ul class="org-ul"><li>Time \(O(n)\)</li><li>Space \(O(1)\)</li></ul></div></div><div id="outline-container-orgheadline7" class="outline-3"><h3 id="pro:leetcode-057"><a id="orgheadline7"></a>057 Insert Interval&nbsp;&nbsp;&nbsp;<span class="tag"><span class="adhoc">adhoc</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-057"><ul class="org-ul"><li>Time \(O(n)\)</li><li>Space \(O(1)\)</li></ul></div></div><div id="outline-container-orgheadline8" class="outline-3"><h3 id="pro:leetcode-078"><a id="orgheadline8"></a>078 Subsets&nbsp;&nbsp;&nbsp;<span class="tag"><span class="adhoc">adhoc</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-078"><ul class="org-ul"><li>Time \(O(n^2)\)</li><li>Space \(O(1)\)</li></ul></div></div><div id="outline-container-orgheadline9" class="outline-3"><h3 id="pro:leetcode-091"><a id="orgheadline9"></a>091 Decode Ways&nbsp;&nbsp;&nbsp;<span class="tag"><span class="adhoc">adhoc</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-091"><ul class="org-ul"><li>Time \(O(n)\)</li><li>Space \(O(1)\)</li></ul></div></div><div id="outline-container-orgheadline10" class="outline-3"><h3 id="pro:leetcode-105"><a id="orgheadline10"></a>105 Construct Binary Tree from Preorder and Inorder Traversal&nbsp;&nbsp;&nbsp;<span class="tag"><span class="bst">bst</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-105"><p>Same as <a href="#pro:leetcode-106">Leetcode 106</a>.</p></div></div><div id="outline-container-orgheadline11" class="outline-3"><h3 id="pro:leetcode-106"><a id="orgheadline11"></a>106 Construct Binary Tree from Inorder and Postorder Traversal&nbsp;&nbsp;&nbsp;<span class="tag"><span class="bst">bst</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-106"><p>Time \(O(n^2)\) space \(O(1)\) or Time \(O(n)\) space \(O(n)\)</p><ul class="org-ul"><li>The last one in post-order traverse is the parent.</li><li>Find the position of the parent in the in-order traverse.</li><li>Recursively construct the left and right children.</li></ul><p>If we store in a hash map all the values' position in the in-order traverse, it runs in \(O(n)\) at the expense of \(O(n)\) space, otherwise it runs in \(O(n^2)\).</p></div></div><div id="outline-container-orgheadline12" class="outline-3"><h3 id="pro:leetcode-113"><a id="orgheadline12"></a>113 Path Sum II&nbsp;&nbsp;&nbsp;<span class="tag"><span class="bfs">bfs</span>&nbsp;<span class="dfs">dfs</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-113"><ul class="org-ul"><li>Time \(O(E+V)\)</li><li>Space \(O(V)\)</li></ul><p>BFS is more space expansive up to a constant factor.</p></div></div><div id="outline-container-orgheadline13" class="outline-3"><h3 id="pro:leetcode-115"><a id="orgheadline13"></a>115 Distinct Sub-sequences&nbsp;&nbsp;&nbsp;<span class="tag"><span class="dp">dp</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-115"><ul class="org-ul"><li>Time \(O(mn)\) where m is length of <code>s</code>, n length of <code>t</code>.</li><li>Space \(O(mn)\)</li></ul><p>Naive divide-and-conquer search fails due to time limit. This could be solved with DP.</p><p>Suppose \(d[i][j]\) holds the number of solution for <code>t[0..i-1]</code> and <code>s[0..j-1]</code>, then <code>d[n][m]</code> is the final solution.</p><p>State transition: \[d[i][j] = \begin{cases} d[i][j-1] + d[i-1][j-1], &amp; \text{if}\ \text{T}[i-1] = \text{S}[j-1] \\ 1, &amp; \text{otherwise} \end{cases}\]</p></div></div><div id="outline-container-orgheadline14" class="outline-3"><h3 id="pro:leetcode-116"><a id="orgheadline14"></a>116 Populating Next Right Pointers in Each Node&nbsp;&nbsp;&nbsp;<span class="tag"><span class="bfs">bfs</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-116"><ul class="org-ul"><li>Time \(O(E+V)\)</li><li>Space \(O(1)\)</li></ul><p>Two loops:</p><ul class="org-ul"><li><code>i</code> iterates "row"</li><li><code>j</code> iterates each level and connects each node's children.</li></ul></div></div><div id="outline-container-orgheadline15" class="outline-3"><h3 id="pro:leetcode-117"><a id="orgheadline15"></a>117 Populating Next Right Pointers in Each Node II&nbsp;&nbsp;&nbsp;<span class="tag"><span class="bfs">bfs</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-117"><ul class="org-ul"><li>Time \(O(E+V)\)</li><li>Space \(O(1)\)</li></ul><p>Similar to <a href="#pro:leetcode-116">Leetcode 116</a>, but in addition, we need to keep track of each level's starting node.</p></div></div><div id="outline-container-orgheadline16" class="outline-3"><h3 id="pro:leetcode-142"><a id="orgheadline16"></a>142 Linked List Cycle II&nbsp;&nbsp;&nbsp;<span class="tag"><span class="slowfastptr">slowfastptr</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-142"><ul class="org-ul"><li>Time \(O(n)\)</li><li>Space \(O(1)\)</li></ul><p>Use slow and fast pointer.</p></div></div><div id="outline-container-orgheadline17" class="outline-3"><h3 id="orgheadline17">166 Fraction to Recurring Decimal&nbsp;&nbsp;&nbsp;<span class="tag"><span class="adhoc">adhoc</span></span></h3><div class="outline-text-3" id="text-orgheadline17"><ul class="org-ul"><li>Time uncertain</li><li>Space uncertain</li></ul><p>Just perform <a href="https://en.wikipedia.org/wiki/Long_division">long division</a>. As for repeating fraction detection, if we come across the same remainder, then we have a repeating fraction from where remainder occurs first.</p><p>Edge cases: negative case, no negative sign when numerator is 0, no decimal point when no fraction part.</p></div></div><div id="outline-container-orgheadline18" class="outline-3"><h3 id="pro:leetcode-199"><a id="orgheadline18"></a>199 Convert Sorted List to Binary Search Tree&nbsp;&nbsp;&nbsp;<span class="tag"><span class="bfs">bfs</span>&nbsp;<span class="dfs">dfs</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-199"><ul class="org-ul"><li>Time \(O(E+V)\)</li><li>Space \(O(V)\)</li></ul><p>Search the tree following BFS or DFS.</p><ul class="org-ul"><li>BFS, record the last element at every level.</li><li>DFS, right-to-left in-order traverse, record the element whenever level increases.</li></ul></div></div><div id="outline-container-orgheadline19" class="outline-3"><h3 id="pro:leetcode-309"><a id="orgheadline19"></a>309 Best Time to Buy and Sell Stock with Cooldown&nbsp;&nbsp;&nbsp;<span class="tag"><span class="dp">dp</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-309"><ul class="org-ul"><li>Time \(O(n^2)\)</li><li>Space \(O(n)\)</li></ul><p>Adpated from <a href="https://leetcode.com/discuss/72892/very-easy-to-understand-one-pass-solution-with-no-extra-space">@GWTW</a> solution. For day k, there are four states.</p><ol class="org-ol"><li>Have stock, do nothing</li><li>Have stock, sell the stock</li><li>Have no stock, do nothing</li><li>Have no stock, buy the stock</li></ol><p>Let <code>a[k]</code>, <code>b[k]</code>, <code>c[k]</code>, <code>d[k]</code> denote the maximum profit on day k ending in each of the four states respectively, <code>P[k]</code> the stock price on day k. The final solution is <code>max(b[n], c[n])</code>.</p><p>State transition:</p><ol class="org-ol"><li><code>a[k + 1] = max(a[k], d[k])</code></li><li><code>b[k + 1] = max(a[k], d[k]) + P[k + 1] - P[k]</code></li><li><code>c[k + 1] = max(b[k], c[k])</code></li><li><code>d[k + 1] = max(c - P[k + 1])</code></li></ol><p>Iterate from day 0 and initial values are all zeros.</p></div></div><div id="outline-container-orgheadline20" class="outline-3"><h3 id="pro:leetcode-367"><a id="orgheadline20"></a>367 Valid Perfect Square&nbsp;&nbsp;&nbsp;<span class="tag"><span class="binarysearch">binarysearch</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-367"><ul class="org-ul"><li>Time \(O(\log n)\)</li><li>Space \(O(1)\)</li></ul><p>The input limits to 32-bit integer, therefore,</p><ul class="org-ul"><li>the running time is actually constant.</li><li>be careful about overflow.</li></ul></div></div></div></div><div id="postamble" class="status"><a class="author" href="http://gongzhitaao.org">Zhitao Gong</a> / <span class="date">2016-10-11 Tue 14:03</span><span class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 25.1.1 (<a href="http://orgmode.org">Org</a> mode 8.3.6)</span></div></body></html>