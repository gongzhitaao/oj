<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Leetcode Summary</title><meta name="generator" content="Org-mode"><meta name="author" content="Zhitao Gong"><link rel="stylesheet" type="text/css" href="http://gongzhitaao.org/orgcss/org.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script></head><body><div id="content"><header><h1 class="title">Leetcode Summary</h1></header><nav id="table-of-contents"><h2>Table of Contents</h2><div id="text-table-of-contents"><ul><li><a href="#orgheadline5">Category</a><ul><li><a href="#orgheadline1">Ad Hoc</a></li><li><a href="#orgheadline2">Dynamic Programming (DP)</a></li><li><a href="#orgheadline3">Search</a></li><li><a href="#orgheadline4">Linked List</a></li></ul></li><li><a href="#orgheadline6">Problems</a><ul><li><a href="#pro:leetcode-014">014 Longest Common Prefix&nbsp;&nbsp;&nbsp;<span class="tag"><span class="adhoc">adhoc</span></span></a></li><li><a href="#pro:leetcode-015">015 3Sum&nbsp;&nbsp;&nbsp;<span class="tag"><span class="adhoc">adhoc</span></span></a></li><li><a href="#pro:leetcode-035">035 Search Insert Position&nbsp;&nbsp;&nbsp;<span class="tag"><span class="binarysearch">binarysearch</span></span></a></li><li><a href="#pro:leetcode-045">045 Jump Game II&nbsp;&nbsp;&nbsp;<span class="tag"><span class="adhoc">adhoc</span></span></a></li><li><a href="#pro:leetcode-057">057 Insert Interval&nbsp;&nbsp;&nbsp;<span class="tag"><span class="adhoc">adhoc</span></span></a></li><li><a href="#pro:leetcode-078">078 Subsets&nbsp;&nbsp;&nbsp;<span class="tag"><span class="adhoc">adhoc</span></span></a></li><li><a href="#pro:leetcode-091">091 Decode Ways&nbsp;&nbsp;&nbsp;<span class="tag"><span class="adhoc">adhoc</span></span></a></li><li><a href="#pro:leetcode-113">113 Path Sum II&nbsp;&nbsp;&nbsp;<span class="tag"><span class="bfs">bfs</span>&nbsp;<span class="dfs">dfs</span></span></a></li><li><a href="#pro:leetcode-116">116 Populating Next Right Pointers in Each Node&nbsp;&nbsp;&nbsp;<span class="tag"><span class="bfs">bfs</span></span></a></li><li><a href="#pro:leetcode-117">117 Populating Next Right Pointers in Each Node II&nbsp;&nbsp;&nbsp;<span class="tag"><span class="bfs">bfs</span></span></a></li><li><a href="#pro:leetcode-142">142 Linked List Cycle II&nbsp;&nbsp;&nbsp;<span class="tag"><span class="slowfastptr">slowfastptr</span></span></a></li><li><a href="#pro:leetcode-199">199 Convert Sorted List to Binary Search Tree&nbsp;&nbsp;&nbsp;<span class="tag"><span class="bfs">bfs</span>&nbsp;<span class="dfs">dfs</span></span></a></li><li><a href="#pro:leetcode-309">309 Best Time to Buy and Sell Stock with Cooldown&nbsp;&nbsp;&nbsp;<span class="tag"><span class="dp">dp</span></span></a></li></ul></li></ul></div></nav><div id="outline-container-orgheadline5" class="outline-2"><h2 id="orgheadline5">Category</h2><div class="outline-text-2" id="text-orgheadline5"></div><div id="outline-container-orgheadline1" class="outline-3"><h3 id="orgheadline1">Ad Hoc</h3><div class="outline-text-3" id="text-orgheadline1"><p><a href="https://leetcode.com/problems/longest-common-prefix/">14</a>, <a href="https://leetcode.com/problems/3sum/">15</a>, <a href="https://leetcode.com/problems/jump-game-ii/">45</a>, <a href="https://leetcode.com/problems/insert-interval/">57</a>, <a href="https://leetcode.com/problems/subsets/">78</a>, <a href="https://leetcode.com/problems/decode-ways/">91</a></p></div></div><div id="outline-container-orgheadline2" class="outline-3"><h3 id="orgheadline2">Dynamic Programming (DP)</h3><div class="outline-text-3" id="text-orgheadline2"><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309</a></p></div></div><div id="outline-container-orgheadline3" class="outline-3"><h3 id="orgheadline3">Search</h3><div class="outline-text-3" id="text-orgheadline3"><ul class="org-ul"><li>Binary search <a href="https://leetcode.com/problems/search-insert-position/">35</a></li><li>Tree search <a href="https://leetcode.com/problems/binary-tree-right-side-view/">199</a>, <a href="https://leetcode.com/problems/path-sum-ii/">113</a>, <a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/">116</a>, <a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/">117</a></li></ul></div></div><div id="outline-container-orgheadline4" class="outline-3"><h3 id="orgheadline4">Linked List</h3><div class="outline-text-3" id="text-orgheadline4"><ul class="org-ul"><li>Slow/fast pointer <a href="https://leetcode.com/problems/linked-list-cycle-ii/">142</a></li></ul></div></div></div><div id="outline-container-orgheadline6" class="outline-2"><h2 id="orgheadline6">Problems</h2><div class="outline-text-2" id="text-orgheadline6"><p>Some assumptions and notations</p><ul class="org-ul"><li>Space and time complexity <b>does not</b> include input and output.</li><li>\(n\) denotes the input length unless noted otherwise.</li><li>In case of graph, \(E\) denotes the number of edges, \(V\) number of vertices/nodes.</li></ul></div><div id="outline-container-orgheadline7" class="outline-3"><h3 id="pro:leetcode-014"><a id="orgheadline7"></a>014 Longest Common Prefix&nbsp;&nbsp;&nbsp;<span class="tag"><span class="adhoc">adhoc</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-014"><p>\(k\) is the length of longest common prefix.</p><ul class="org-ul"><li>Time \(O(nk)\)</li><li>Space \(O(1)\)</li></ul></div></div><div id="outline-container-orgheadline8" class="outline-3"><h3 id="pro:leetcode-015"><a id="orgheadline8"></a>015 3Sum&nbsp;&nbsp;&nbsp;<span class="tag"><span class="adhoc">adhoc</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-015"><ul class="org-ul"><li>Time \(O(n^2)\)</li><li>Space \(O(1)\)</li></ul><p>Sort the array first, then use two loops:</p><ul class="org-ul"><li>outer one <code>i</code> ranges <code>[0, n-3)</code></li><li>inner one <code>j</code> starts from <code>i</code>, <code>k</code> starts from the end,<ul class="org-ul"><li>if sum is greater than expected, move <code>k</code> left,</li><li>if sum is less than expected, move <code>j</code> right,</li><li>otherwise move <code>j</code> right and <code>k</code> left</li><li>until they meet</li></ul></li></ul><figure><p><img src="img/leetcode-014.png" alt="leetcode-014.png"></p></figure></div></div><div id="outline-container-orgheadline9" class="outline-3"><h3 id="pro:leetcode-035"><a id="orgheadline9"></a>035 Search Insert Position&nbsp;&nbsp;&nbsp;<span class="tag"><span class="binarysearch">binarysearch</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-035"><ul class="org-ul"><li>Time \(O(\log n)\)</li><li>Space \(O(1)\)</li></ul><p>See the <code>C++</code> std implementation of <code>upper_bound</code> or <code>lower_bound</code>.</p></div></div><div id="outline-container-orgheadline10" class="outline-3"><h3 id="pro:leetcode-045"><a id="orgheadline10"></a>045 Jump Game II&nbsp;&nbsp;&nbsp;<span class="tag"><span class="adhoc">adhoc</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-045"><ul class="org-ul"><li>Time \(O(n)\)</li><li>Space \(O(1)\)</li></ul></div></div><div id="outline-container-orgheadline11" class="outline-3"><h3 id="pro:leetcode-057"><a id="orgheadline11"></a>057 Insert Interval&nbsp;&nbsp;&nbsp;<span class="tag"><span class="adhoc">adhoc</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-057"><ul class="org-ul"><li>Time \(O(n)\)</li><li>Space \(O(1)\)</li></ul></div></div><div id="outline-container-orgheadline12" class="outline-3"><h3 id="pro:leetcode-078"><a id="orgheadline12"></a>078 Subsets&nbsp;&nbsp;&nbsp;<span class="tag"><span class="adhoc">adhoc</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-078"><ul class="org-ul"><li>Time \(O(n^2)\)</li><li>Space \(O(1)\)</li></ul></div></div><div id="outline-container-orgheadline13" class="outline-3"><h3 id="pro:leetcode-091"><a id="orgheadline13"></a>091 Decode Ways&nbsp;&nbsp;&nbsp;<span class="tag"><span class="adhoc">adhoc</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-091"><ul class="org-ul"><li>Time \(O(n)\)</li><li>Space \(O(1)\)</li></ul></div></div><div id="outline-container-orgheadline14" class="outline-3"><h3 id="pro:leetcode-113"><a id="orgheadline14"></a>113 Path Sum II&nbsp;&nbsp;&nbsp;<span class="tag"><span class="bfs">bfs</span>&nbsp;<span class="dfs">dfs</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-113"><ul class="org-ul"><li>Time \(O(E+V)\)</li><li>Space \(O(V)\)</li></ul><p>BFS is more space expansive up to a constant factor.</p></div></div><div id="outline-container-orgheadline15" class="outline-3"><h3 id="pro:leetcode-116"><a id="orgheadline15"></a>116 Populating Next Right Pointers in Each Node&nbsp;&nbsp;&nbsp;<span class="tag"><span class="bfs">bfs</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-116"><ul class="org-ul"><li>Time \(O(E+V)\)</li><li>Space \(O(1)\)</li></ul><p>Two loops:</p><ul class="org-ul"><li><code>i</code> iterates "row"</li><li><code>j</code> iterates each level and connects each node's children.</li></ul></div></div><div id="outline-container-orgheadline16" class="outline-3"><h3 id="pro:leetcode-117"><a id="orgheadline16"></a>117 Populating Next Right Pointers in Each Node II&nbsp;&nbsp;&nbsp;<span class="tag"><span class="bfs">bfs</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-117"><ul class="org-ul"><li>Time \(O(E+V)\)</li><li>Space \(O(1)\)</li></ul><p>Similar to <a href="#pro:leetcode-116">116 Populating Next Right Pointers in Each Node</a>, we need to keep track of each level's starting node.</p></div></div><div id="outline-container-orgheadline17" class="outline-3"><h3 id="pro:leetcode-142"><a id="orgheadline17"></a>142 Linked List Cycle II&nbsp;&nbsp;&nbsp;<span class="tag"><span class="slowfastptr">slowfastptr</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-142"><ul class="org-ul"><li>Time \(O(n)\)</li><li>Space \(O(1)\)</li></ul><p>Use slow and fast pointer.</p></div></div><div id="outline-container-orgheadline18" class="outline-3"><h3 id="pro:leetcode-199"><a id="orgheadline18"></a>199 Convert Sorted List to Binary Search Tree&nbsp;&nbsp;&nbsp;<span class="tag"><span class="bfs">bfs</span>&nbsp;<span class="dfs">dfs</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-199"><ul class="org-ul"><li>Time \(O(E+V)\)</li><li>Space \(O(V)\)</li></ul><p>Search the tree following BFS or DFS.</p><ul class="org-ul"><li>BFS, record the last element at every level.</li><li>DFS, right-to-left in-order traverse, record the element when level increases.</li></ul></div></div><div id="outline-container-orgheadline19" class="outline-3"><h3 id="pro:leetcode-309"><a id="orgheadline19"></a>309 Best Time to Buy and Sell Stock with Cooldown&nbsp;&nbsp;&nbsp;<span class="tag"><span class="dp">dp</span></span></h3><div class="outline-text-3" id="text-pro:leetcode-309"><ul class="org-ul"><li>Time \(O(n^2)\)</li><li>Space \(O(n)\)</li></ul><p>Adpated from <a href="https://leetcode.com/discuss/72892/very-easy-to-understand-one-pass-solution-with-no-extra-space">@GWTW</a> solution. For day k, there are four states.</p><ol class="org-ol"><li>Have stock, do nothing</li><li>Have stock, sell the stock</li><li>Have no stock, do nothing</li><li>Have no stock, buy the stock</li></ol><p>Let <code>a[k]</code>, <code>b[k]</code>, <code>c[k]</code>, <code>d[k]</code> denote the maximum profit on day k ending in each of the four states respectively, <code>P[k]</code> the stock price on day k. The final solution is <code>max(b[n], c[n])</code>.</p><p>State transition:</p><ol class="org-ol"><li><code>a[k + 1] = max(a[k], d[k])</code></li><li><code>b[k + 1] = max(a[k], d[k]) + P[k + 1] - P[k]</code></li><li><code>c[k + 1] = max(b[k], c[k])</code></li><li><code>d[k + 1] = max(c - P[k + 1])</code></li></ol><p>Iterate from day 0 and initial values are all zeros.</p></div></div></div></div><div id="postamble" class="status"><a class="author" href="http://gongzhitaao.org">Zhitao Gong</a> / <span class="date">2016-09-11 Sun 11:03</span><span class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.5.1 (<a href="http://orgmode.org">Org</a> mode 8.3.5)</span></div></body></html>